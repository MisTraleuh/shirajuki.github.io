<!doctype html>
<html>

<head>
  <title>HTML5 Canvas - 3D projecting</title>
  <meta charset="utf-8" />
  <style>
    canvas {
      background: black;
      display: block;
      margin: 0 auto;
      width:100vw;
      height:100vh;
    }
    * {
      padding: 0;
      margin: 0;
    }
    .box {
      display: block;
      position: absolute;
      margin: 10px;
      width: 150px;
      top: 0;
      left: 0;
      z-index: 100;
      color: white;
    }
    p {
      margin: 5px 0;
      padding: 10px;
      background-color: rgba(255, 255, 255, 0.5);
      border-radius: 10px;
    }
  </style>
</head>

<body>
  <canvas id="myCanvas" width="600" height="600"></canvas>
  <div class="box">
    <input type="file" name="file" id="file"/>
    <p>Load .txt file with a list of vertex points given: "v x y z"</p>
  </div>
  <div id="box2"></div>
  <script type="text/javascript" src="dat.gui.min.js"></script>
  <script type="text/javascript" src="stats.min.js"></script>
  <script>
    /*
    Done using:
      https://en.wikipedia.org/wiki/3D_projection#Orthographic_projection
      https://en.wikipedia.org/wiki/Rotation_matrix
    */

    // stats.js
    const stats = new Stats();
    stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
    stats.dom.style = 'position: fixed;bottom: 0px;left: 0px;cursor: pointer;opacity: 0.9;z-index: 10000;'
    document.getElementById('box2').appendChild( stats.dom );

    //// CONFIG
    let canvas = document.getElementById("myCanvas");
    let width = canvas.offsetWidth; // Width of the scene
    let height = canvas.offsetHeight; // Height of the scene
    let ctx = canvas.getContext("2d");
    // Function called right after user resized its screen
    function onResize () {
      // We need to define the dimensions of the canvas to our canvas element
      // Javascript doesn't know the computed dimensions from CSS so we need to do it manually
      width = canvas.offsetWidth;
      height = canvas.offsetHeight;

      // If the screen device has a pixel ratio over 1
      // We render the canvas twice bigger to make it sharper (e.g. Retina iPhone)
      if (window.devicePixelRatio > 1) {
        canvas.width = canvas.clientWidth * 2;
        canvas.height = canvas.clientHeight * 2;
        ctx.scale(2, 2);
      } else {
        canvas.width = width;
        canvas.height = height;
      }
    }

    // Listen to resize events
    window.addEventListener('resize', onResize);
    // Make sure the canvas size is perfect
    onResize();
    // Object settings
    let center = [canvas.width/2,canvas.height/2];
    let color = 'white',size = 10,zoom = 0.1,speed = 0.03,offsetX = 10,offsetY = 10;
    let rotateX = false, rotateY = false, stopAnimation = false;
    // Thing variable
    let thing = [
      [-1, -1, -1],
      [1, -1, -1],
      [-1, 1, -1],
      [1, 1, -1],
      [-1, -1, 1],
      [1, -1, 1],
      [-1, 1, 1],
      [1, 1, 1],
    ];
    // Rotation vinkel
    let theta = 0;
    /*
    Formel:
    bx = scale*ax + offsetX
    by = scale*ay + offsetY
    */
    // dat.gui.js
    let config,gui;
    function Config() {
      this.size = 10;
      this.zoom = 50;
      this.speed = 0.03;
      this.offsetX = 0;
      this.offsetY = 0;
      this.rotateX = true;
      this.rotateY = false;
      this.stopAnimation = false;
      this.color = "#fff";
    };
    window.onload = function() {
      config = new Config();
      gui = new dat.GUI();
      gui.add(config, 'size', 0, 50);
      gui.add(config, 'zoom', -200, 200);
      gui.add(config, 'speed', -0.5, 0.5,);
      gui.add(config, 'offsetX', -500, 500);
      gui.add(config, 'offsetY', -500, 500);
      gui.add(config, 'rotateX');
      gui.add(config, 'rotateY');
      gui.add(config, 'stopAnimation');
      gui.addColor(config, 'color');
      draw()
    };
    function update() {
      color = config.color;
      size = config.size;
      zoom = config.zoom;
      speed = config.speed;
      offsetX = config.offsetX;
      offsetY = config.offsetY;
      rotateX = config.rotateX;
      rotateY = config.rotateY;
      stopAnimation = config.stopAnimation;
    }
    // Read from txt file, "v x y z"
    document.getElementById('file').onchange = function(){
      let file = this.files[0];
      let reader = new FileReader();
      reader.onload = function(progressEvent){
        let lines = this.result.split('\n');
        let length = lines[0].split(' ').length
        let n = 0;
        //console.log(lines[0].split(' '))
        if (length > 4) n = length - 4;
        for (let i = 0; i < lines.length-1; i++){
          if (i == 0) thing = [];
          let text = lines[i].split(' ');
          //console.log(`[${text[1]},${text[2]},${text[3]}]`)
          if (thing[i] !== null) thing[i] = JSON.parse(`[${text[1+n]},${text[2+n]},${text[3+n]}]`);
        }
      };
      reader.readAsText(file);
    };
    // Draw circle
    function circle(x, y, width, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(x, y, width / 2, 0, 2 * Math.PI);
      ctx.fill();
      ctx.closePath();
    }
    // Draw rectangle
    function rect(x, y, width, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.rect(x, y, width, width);
      ctx.fill();
      ctx.closePath();
    }
    // Matte kryssprodukt, you know it.
    function matriseMulti(matrise3d,matrise2d) {
      x = matrise3d[0][0]*matrise2d[0] + matrise3d[0][1]*matrise2d[1] + matrise3d[0][2]*matrise2d[2];
      y = matrise3d[1][0]*matrise2d[0] + matrise3d[1][1]*matrise2d[1] + matrise3d[1][2]*matrise2d[2];
      z = 0;
      return [x,y,z]
    }
    // Funksjon for Ã¥ tegne
    function draw() {
      stats.begin()
      // Sletter hele canvas for hver iterasjon --> lager animasjon
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      update();
      let scale = [
        [zoom,0,0],
        [0,zoom,0],
      ];
      let Rx = [
        [1, 0, 0],
        [0, Math.cos(theta), -Math.sin(theta)],
        [0, Math.sin(theta), Math.cos(theta)],
      ];
      let Ry = [
        [Math.cos(theta), 0, Math.sin(theta)],
        [0, 1, 0],
        [-Math.sin(theta), 0, Math.cos(theta)],
      ];
      let Rz = [
        [Math.cos(theta), -Math.sin(theta), 0],
        [Math.sin(theta), Math.cos(theta), 0],
        [0, 0, 1],
      ];
      // Loop
      let rotert = thing[0], projected = thing[0];
      for (let i = 0; i < thing.length; i++) {
        let a = thing[i];
        if (rotateX) rotert = matriseMulti(Ry,a);
        if (rotateY && !rotateX) rotert = matriseMulti(Rx,a);
        if (rotateX && rotateY) rotert = matriseMulti(Rz,rotert);
        projected = matriseMulti(scale,rotert);
        if (!rotateX && !rotateY) projected = matriseMulti(scale,a);
        bx = projected[0]+offsetX;
        by = projected[1]+offsetY;
        circle(-bx+center[0],-by+center[1],size,color)
      }
      // Vinkel
      if (!stopAnimation) theta += speed;
      stats.end()
      requestAnimationFrame(draw);
    }
  </script>
</body>

</html>
